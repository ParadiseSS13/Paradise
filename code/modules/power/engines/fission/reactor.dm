// the steps for repairing the reactor
#define REACTOR_NEEDS_DIGGING 		1
#define REACTOR_NEEDS_CROWBAR 		2
#define REACTOR_NEEDS_PLASTITANIUM	3
#define REACTOR_NEEDS_WRENCH		4
#define REACTOR_NEEDS_WELDING		5
#define REACTOR_NEEDS_PLASTEEL		6
#define REACTOR_NEEDS_SCREWDRIVER	7

#define REACTOR_LIGHT_COLOR "#569fff"

#define TOTAL_CONTROL_RODS 5 // The max number of control rods.

#define MIN_CHAMBERS_TO_OVERLOAD 20 // The amount of conencted chambers required before the overload is valid

#define EVENT_MODIFIER 0.5 // multiplies the commonality of dangerous events.

#define HEAT_MODIFIER 400 // a flat multiplier. Higher = more heat production.
#define HEAT_CAP 40000 // the highest temp before we artificially cap it
#define AVERAGE_HEAT_THRESHOLD 50 // The threshold the average heat-per-rod must exceed to generate coefficient.
#define TOTAL_HEAT_THRESHOLD 600 // the temp (in K) needed to begin generating coefficient.
#define HEAT_CONVERSION_RATIO 400 // How much heat over the threshold = an extra coefficient point.
#define REACTIVITY_COEFFICIENT_CAP 30 // The highest that reactivity coefficient can be

// If integrity percent remaining is less than these values, the monitor sets off the relevant alarm.
#define NGCR_MELTDOWN_PERCENT 5
#define NGCR_EMERGENCY_PERCENT 25
#define NGCR_DANGER_PERCENT 50
#define NGCR_WARNING_PERCENT 100
#define CRITICAL_TEMPERATURE 10000
#define WARNING_POINT 50 // begin sending warning messages
#define EMERGENCY_POINT 700 // Begin sending warning messages over common
#define MELTDOWN_POINT 1000 // The dammage cap where meltdown occurs. higher = longer to meltdown

#define NGCR_COUNTDOWN_TIME 30 SECONDS // How long the meltdown countdown lasts
#define WARNING_DELAY 60 // time in deciseconds between warnings

#define HEAT_DAMAGE_RATE 500 // The rate at which damage increases due to heat
#define MOL_MINIMUM 30 // The amount of mols of gas needed before it begins to take damage while operational
#define PRESSURE_MAXIMUM 20000 // The highest safe pressure allowed by the reactor
#define PRESSURE_DAMAGE 0.5 // the minimum damage caused by overpresurization
#define DAMAGE_MINIMUM 0.002 // The minimum amount of damage done when taking any damage
#define DAMAGE_MAXIMUM 8 // The highest amount of damage done when taking damage
#define MOL_DAMAGE_MULTIPLIER 1 // an adjuster for damage balance from no gas
#define HEAT_DAMAGE_MULTIPLIER 1 // an adjuster for damage balance from high heat
#define EXPLOSION_MODIFIER 4 // Adjusts the size of the engine explosion

#define CHAMBER_HEAT_DAMAGE 15 // How much damage reactor chambers do when on.

#define MOLE_BONUS_THRESHOLD 800 // The minimum number of moles needed to begin accruing multiplier.
#define MOLE_BONUS_COMPONENT 250 // how many moles are required for one "unit" of modifier increase. Used in the math calculation.
#define N2_OVERHEAT_BONUS 600 // The overheat threshold bonus that N2 coolant provides
#define N2_EVENT_MODIFIER 20 // The negative event chance from N2.
#define N2O_OVERHEAT_BONUS 300 // The overheat threshold bonus that N2O coolant provides
#define N2O_EVENT_MODIFIER 20 // The negative event chance from N2O.
#define CO2_EVENT_MODIFIER 60 // The negative event chance from CO2.
#define O2_EVENT_MODIFIER -50 // The POSITIVE event chance from N2.
#define O2_REACTIVITY_BONUS 0.8 // the highest amount of reactivity that O2 coolant provides
#define PLASMA_REACTIVITY_BONUS 0.2 // the highest amount of reactivity that plasma coolant provides
#define PLASMA_OVERHEAT_BONUS 200 // // The overheat threshold bonus that plasma coolant provides

/// MARK: Fission Reactor
/obj/machinery/atmospherics/fission_reactor
	name = "Nuclear Fission Reactor"
	desc = "An ancient yet reliable form of power generation utilising fissile materials to generate heat."
	icon = 'icons/goonstation/objects/reactor.dmi'
	icon_state = "reactor_off"
	density = TRUE
	resistance_flags = INDESTRUCTIBLE | LAVA_PROOF | FIRE_PROOF | UNACIDABLE | ACID_PROOF | FREEZE_PROOF
	pixel_x = -32
	flags_2 = NO_MALF_EFFECT_2

	/// Holds the list for the connected reactor chambers to take data from
	var/list/connected_chambers = list()
	/// Prevents the reactor from making power under certain circumstances
	var/can_create_power = TRUE
	/// The total amount of heat gathered in the reactor
	var/final_heat
	/// The total amount of power being generated by the engine (in watts)
	var/final_power
	/// The user-controlled rods used to change how active the reactor is
	var/control_rod_percentage = 0
	/// A modifier for general reactivity, based off of heat production. Cant go below 1
	var/reactivity_multiplier = 1
	/// How many functional control rods does the reactor have?
	var/control_rods_remaining = 5
	/// what repair step is the reactor on?
	var/repair_step = 1
	/// the desired percentage the engineers set the reactor control rods
	var/desired_power = 0
	/// What percentage are the reactor control rods running at? Minimum raised for each broken control rod
	var/operating_power = 0
	/// The amount of damage we have currently. Use adjust_damage() to change it
	var/damage = 0
	/// Is this the primary station engine that spawns in round? Basically
	var/primary_engine = FALSE
	/// Has the engine warmed up enough to start
	var/starting_up = TRUE
	/// Is the engine currently fully offline
	var/offline = TRUE
	/// The heat (in K) before the reactor accrues damage
	var/heat_damage_threshold = 1000
	/// The amount of heat created by averaging total heat against all rods
	var/average_heatgen = 0
	/// The alert we send when we've reached warning_point
	var/warning_alert = "Danger! Reactor core chamber meltdown in progress!"
	/// Our "Shit is no longer fucked" message. We send it when temp_damage is 0
	var/safe_alert = "Reactor conditions stabilized within operating parameters. Core meltdown averted."
	/// The alert we send when we've reached emergency_point
	var/emergency_alert = "REACTOR CORE MELTDOWN IMMINENT."
	/// Time in 1/10th of seconds since the last sent warning
	var/lastwarning = 0
	/// a boolean value for if we need to send out an alert. (usually during meltdowns)
	var/send_message = FALSE
	/// Are we giving the final countdown to meltdown
	var/final_countdown = FALSE
	/// Are admins freezing the reactor for whatever reason
	var/admin_intervention = FALSE
	/// An admin-triggered var for enabling the station-ending self destruct
	var/safety_override = FALSE
	/// Disables changing the desired power value
	var/control_lockout = FALSE
	/// Toggles whether the reactor is erupting
	var/venting = FALSE
	/// Is the vent allowed to be closed without manual intervention?
	var/vent_lockout = FALSE
	/// How often do we want to process the vent?
	var/ticks_per_run = 20
	/// How long has it been since we processed the vent?
	var/tick_counter = 0
	/// What is the lowest temperature the reactor wants to be at?
	var/minimum_operating_temp = 0
	/// Holds the bonus to overheat threshold from gasses
	var/gas_overheat_bonus = 0
	/// Holds the bonus to reactivity from gasses
	var/gas_reactivity_bonus = 0
	/// Affects the current negative event chances
	var/gas_event_modifier = 1
	/// Our running soundloop
	var/datum/looping_sound/reactor/soundloop
	/// Our startup soundloop
	var/datum/looping_sound/reactor_startup/startloop
	/// The current air contents of this device
	var/datum/gas_mixture/air_contents
	/// Holds the grill for the reactor.
	var/obj/machinery/cooking/grill/loaded/reactor/grill
	/// Our internal radio
	var/obj/item/radio/radio

/obj/machinery/atmospherics/fission_reactor/roundstart
	primary_engine = TRUE

/obj/machinery/atmospherics/fission_reactor/examine(mob/user)
	. = ..()
	if(stat & BROKEN)
		. += "A burning hole remains where the NGCR Reactor housed its core. Its inoperable in this state. The acrid smell permeates through even the thickest of suits."
		return
	if(venting)
		. += SPAN_NOTICE("A crowbar can be used to close the malfunctioning vent.")
	if(grill)
		. += SPAN_NOTICE("Wirecutters can be used to remove the grill.")
	switch(repair_step)
		if(REACTOR_NEEDS_DIGGING)
			. += SPAN_NOTICE("A shovel will be needed to extract all of the melted corium.")
		if(REACTOR_NEEDS_CROWBAR)
			. += SPAN_NOTICE("The old broken plating needs to be removed with a crowbar.")
		if(REACTOR_NEEDS_PLASTITANIUM)
			. += SPAN_NOTICE("The reactor requires a new plastitanium core.")
		if(REACTOR_NEEDS_WRENCH)
			. += SPAN_NOTICE("The new plastitanium core needs to be wrenched into place.")
		if(REACTOR_NEEDS_WELDING)
			. += SPAN_NOTICE("The new plastitanium core needs welded into place.")
		if(REACTOR_NEEDS_PLASTEEL)
			. += SPAN_NOTICE("The new plastitanium core needs a new plasteel housing cover.")
		if(REACTOR_NEEDS_SCREWDRIVER)
			. += SPAN_NOTICE("The plasteel housing cover needs screwed into place.")

/obj/machinery/atmospherics/fission_reactor/examine_more(mob/user)
	. = ..()
	. += "The NGCR-5600 Nuclear Reactor was first actualized as a replacement for older, static nuclear or coal models before the discovery of supermatter harvesting techniques. \
	This reactor became widespread due to the modularity and ease of use of existing station materials, allowing it to be inserted into most stations that possessed basic engineering infrastructure."
	. += ""
	. += "However, despite the popularity of the engine, the need for frequent upkeep and higher energy demands led to innovations in newer, more advanced energy sources. \
	This engine soon became a relic of the past, but still remains a staple in many stations due to what Nanotrasen calls its 'long term reliability'."

/obj/machinery/atmospherics/fission_reactor/Initialize(mapload)
	. = ..()
	AddComponent(/datum/component/multitile, list(
		list(1, MACH_CENTER, 1),
	))
	air_contents = new
	air_contents.volume = 1000 // kpa
	air_contents.set_oxygen(MOLES_O2STANDARD * 0.6)
	air_contents.set_nitrogen(MOLES_N2STANDARD * 0.6)
	air_contents.set_temperature(T20C)
	GLOB.poi_list |= src
	radio = new(src)
	radio.listening = FALSE
	radio.follow_target = src
	radio.config(list("Engineering" = 0))
	if(primary_engine)
		GLOB.main_fission_reactor = src
	soundloop = new(list(src), FALSE)
	startloop = new(list(src), FALSE)
	update_icon(UPDATE_OVERLAYS)

/obj/machinery/atmospherics/fission_reactor/ex_act(severity)
	if(severity == EXPLODE_DEVASTATE) // Very sturdy.
		set_broken()
	else if(severity == EXPLODE_HEAVY)
		adjust_damage(rand(100,300))
	else
		adjust_damage(rand(30, 150))

/obj/machinery/atmospherics/fission_reactor/blob_act(obj/structure/blob/B)
	adjust_damage(rand(20, 60))

/obj/machinery/atmospherics/fission_reactor/zap_act(power, zap_flags)
	. = ..()
	if(zap_flags & ZAP_MACHINE_EXPLOSIVE)
		qdel(src) //like the singulo, tesla deletes it. stops it from exploding over and over

// This shouldnt happen normally
/obj/machinery/atmospherics/fission_reactor/Destroy()
	investigate_log("was destroyed!", INVESTIGATE_REACTOR)
	clear_reactor_network()
	QDEL_NULL(soundloop)
	QDEL_NULL(startloop)
	QDEL_NULL(air_contents)
	QDEL_NULL(grill)
	QDEL_NULL(radio)
	return ..()

/obj/machinery/atmospherics/fission_reactor/update_overlays()
	. = ..()
	if(!(stat & BROKEN))
		var/rod_state = round((100 - operating_power + 24) / 25)
		rod_state = clamp(rod_state, 1, 5)
		. += "rods_[control_rods_remaining]_[rod_state]"

/// Links all valid chambers to the reactor itself.
/obj/machinery/atmospherics/fission_reactor/proc/build_reactor_network()
	for(var/turf/T in RECT_TURFS(1, 2, src))
		for(var/obj/machinery/atmospherics/reactor_chamber/chamber in T)
			if(!chamber.linked_reactor && !chamber.skip_link)
				chamber.find_link(src)

/obj/machinery/atmospherics/fission_reactor/proc/clear_reactor_network(restart = FALSE)
	for(var/obj/machinery/atmospherics/reactor_chamber/linked in connected_chambers)
		linked.linked_reactor = null
		connected_chambers -= linked
	if(length(connected_chambers))
		log_debug("clear_reactor_network ran successfully, however connected_chambers still contains items!")
		connected_chambers.Cut()
	if(restart)
		build_reactor_network()

/obj/machinery/atmospherics/fission_reactor/proc/set_broken(meltdown = TRUE)
	if(stat & BROKEN)
		return

	stat |= BROKEN
	overlays = null

	if(safety_override && operating_power >= 100)
		INVOKE_ASYNC(src, PROC_REF(finalize_overload))
		return

	clear_reactor_network()
	if(meltdown) // in case we dont want a violent explosion
		INVOKE_ASYNC(src, PROC_REF(meltdown))
	else
		icon_state = "broken"

/// Begin the meltdown process
/obj/machinery/atmospherics/fission_reactor/proc/meltdown()
	update_appearance(UPDATE_OVERLAYS)
	icon_state = "meltdown"
	sleep(2.5 SECONDS)
	var/explosion_modifier = clamp(reactivity_multiplier * EXPLOSION_MODIFIER, 8, 40)
	explosion(src.loc, explosion_modifier / 2, explosion_modifier, explosion_modifier + 3, explosion_modifier + 6, ignorecap = TRUE, smoke = TRUE)
	icon_state = "broken"

/obj/machinery/atmospherics/fission_reactor/proc/set_fixed()
	stat &= ~BROKEN
	icon = "reactor_off"
	build_reactor_network()

/obj/machinery/atmospherics/fission_reactor/item_interaction(mob/living/user, obj/item/used, list/modifiers)
	. = ..()
	if(!iscarbon(user))
		return
	var/mob/living/carbon/creature = user
	if(istype(used, /obj/item/shovel) && repair_step == REACTOR_NEEDS_DIGGING)
		playsound(src, used.usesound, 50, 1)
		if(do_after_once(creature, 3 SECONDS, TRUE, src, allow_moving = FALSE))
			playsound(src, used.usesound, 50, 1)
			new /obj/item/slag(loc)
			if(prob(20))
				repair_step++
				to_chat(creature, SPAN_INFORMATION("There seems to be more slag clogging the ruined reactor core."))
			else
				to_chat(creature, SPAN_INFORMATION("No more melted slag remains in the chamber."))
		return ITEM_INTERACT_COMPLETE
	if(istype(used, /obj/item/stack/sheet/mineral/plastitanium))
		var/obj/item/stack/sheet/plastitanium = used
		if(plastitanium.amount >= 5)
			if(repair_step == REACTOR_NEEDS_PLASTITANIUM)
				if(do_after_once(creature, 3 SECONDS, TRUE, src, allow_moving = FALSE))
					plastitanium.use(5)
					to_chat(creature, SPAN_INFORMATION("You reform the control rod housing and slot the structure into place."))
					repair_step++
					icon = "reactor_maintenance"
			else
				if(!offline)
					to_chat(creature, SPAN_WARNING("The reactor must be off to repair it!"))
					return ITEM_INTERACT_COMPLETE
				if(damage == 0)
					to_chat(creature, SPAN_WARNING("The reactor has nothing left to repair!"))
					return ITEM_INTERACT_COMPLETE
				var/obj/item/item = creature.get_inactive_hand()
				if(!istype(item, /obj/item/weldingtool))
					to_chat(creature, SPAN_WARNING("A functional welder is required to adhere the plastitanium."))
					return ITEM_INTERACT_COMPLETE
				if(!item.use_tool(src, creature, 0, amount = 1, volume = item.tool_volume))
					return ITEM_INTERACT_COMPLETE
				if(do_after_once(creature, 4 SECONDS, TRUE, src, allow_moving = FALSE))
					plastitanium.use(5)
					adjust_damage((-MELTDOWN_POINT * 0.1))
		else
			to_chat(creature, SPAN_WARNING("You need at least five sheets of plastitanium to reform the reactor core structure!"))
		return ITEM_INTERACT_COMPLETE
	if(istype(used, /obj/item/stack/sheet/plasteel) && repair_step == REACTOR_NEEDS_PLASTEEL)
		var/obj/item/stack/sheet/plasteel = used
		if(plasteel.amount >= 5)
			if(do_after_once(user, 3 SECONDS, TRUE, src, allow_moving = FALSE))
				repair_step++
				plasteel.use(5)
				to_chat(user, SPAN_INFORMATION("You attach a layer of radiation shielding around the reactor core."))
		else
			to_chat(user, SPAN_WARNING("You need at least five sheets of plasteel to reform the reactor core structure."))
		return ITEM_INTERACT_COMPLETE
	if(istype(used, /obj/item/reagent_containers/cooking/grill_grate))
		if(!grill)
			var/obj/item/item = creature.get_inactive_hand()
			if(istype(item, /obj/item/reagent_containers/cooking/grill_grate))
				qdel(used)
				qdel(item)
				grill = new(loc)
				return ITEM_INTERACT_COMPLETE
			else
				to_chat(user, SPAN_WARNING("You need a second grate to set up a proper grill."))
				return ITEM_INTERACT_COMPLETE
		else
			to_chat(user, SPAN_WARNING("There are already grill grates adhered to the surface of the reactor."))
			return ITEM_INTERACT_COMPLETE

/obj/machinery/atmospherics/fission_reactor/wirecutter_act(mob/living/user, obj/item/I)
	if(grill)
		to_chat(user, "<span class='warning'>You begin cutting the adhered grates from the reactor body...")
		if(I.use_tool(src, user, 4 SECONDS, volume = I.tool_volume))
			new /obj/item/reagent_containers/cooking/grill_grate(loc)
			new /obj/item/reagent_containers/cooking/grill_grate(loc)
			QDEL_NULL(grill)
		return ITEM_INTERACT_COMPLETE

/obj/machinery/atmospherics/fission_reactor/crowbar_act(mob/living/user, obj/item/I)
	if(repair_step == REACTOR_NEEDS_CROWBAR)
		if(I.use_tool(src, user, 1 SECONDS, volume = I.tool_volume))
			playsound(src, I.usesound, 50, 1)
			repair_step++
			to_chat(user, SPAN_INFORMATION("You remove any remaining damaged structure from the housing."))
			new /obj/item/stack/sheet/metal(user.loc, 2)
		return ITEM_INTERACT_COMPLETE
	if(!(stat & BROKEN) && venting)
		if(I.use_tool(src, user, (8 SECONDS * I.toolspeed), volume = I.tool_volume))
			venting = FALSE
			return ITEM_INTERACT_COMPLETE


/obj/machinery/atmospherics/fission_reactor/wrench_act(mob/living/user, obj/item/I)
	if(repair_step == REACTOR_NEEDS_WRENCH)
		if(I.use_tool(src, user, 1 SECONDS, volume = 50))
			playsound(src, I.usesound, 50, 1)
			repair_step++
			to_chat(user, SPAN_INFORMATION("You secure the new plastitanium structure in place."))
			new /obj/item/stack/sheet/metal(user.loc, 2)
		return ITEM_INTERACT_COMPLETE
	if(!(stat & BROKEN) && control_rods_remaining < TOTAL_CONTROL_RODS)
		if(I.use_tool(src, user, (0 SECONDS * I.toolspeed), volume = I.tool_volume))
			if(!do_after_once(user, 8 SECONDS, allow_moving = FALSE))
				control_rods_remaining++
				update_icon(UPDATE_OVERLAYS)
			return ITEM_INTERACT_COMPLETE


/obj/machinery/atmospherics/fission_reactor/screwdriver_act(mob/living/user, obj/item/I)
	if(repair_step == REACTOR_NEEDS_SCREWDRIVER)
		if(I.use_tool(src, user, 1 SECONDS, volume = 50))
			playsound(src, I.usesound, 50, 1)
			to_chat(user, SPAN_INFORMATION("You secure the radiation shielding into place."))
			set_fixed()
		return ITEM_INTERACT_COMPLETE

/obj/machinery/atmospherics/fission_reactor/welder_act(mob/living/user, obj/item/I)
	if(repair_step == REACTOR_NEEDS_WELDING)
		if(I.use_tool(src, user, 1 SECONDS, volume = 50))
			playsound(src, I.usesound, 50, 1)
			repair_step++
			to_chat(user, SPAN_INFORMATION("You weld together the framing, ensuring an airtight seal within the core."))
			new /obj/item/stack/sheet/metal(user.loc, 2)
		return ITEM_INTERACT_COMPLETE

/obj/machinery/atmospherics/fission_reactor/proc/get_integrity()
	var/integrity = damage / MELTDOWN_POINT
	integrity = round(100 - integrity * 100, 0.01)
	integrity = integrity < 0 ? 0 : integrity
	return integrity

/obj/machinery/atmospherics/fission_reactor/multitool_act(mob/living/user, obj/item/I)
	if(!I.use_tool(src, user, 0, volume = I.tool_volume))
		return
	. = TRUE
	var/obj/item/multitool/multi = I
	multi.set_multitool_buffer(user, src)

/obj/machinery/atmospherics/fission_reactor/process_atmos()
	if(!venting)
		return

	if(admin_intervention)
		return

	tick_counter += SSair.wait
	if(tick_counter >= ticks_per_run)
		var/datum/milla_safe/reactor_process/milla = new()
		milla.invoke_async(src)
		tick_counter -= ticks_per_run

/datum/milla_safe/reactor_process

/datum/milla_safe/reactor_process/on_run(obj/machinery/atmospherics/fission_reactor/reactor)
	var/turf/T = get_turf(reactor)
	var/datum/gas_mixture/environment = get_turf_air(T)

	if(isnull(T)) // We have a null turf...something is wrong, stop processing this entity.
		return PROCESS_KILL

	if(!istype(reactor.loc, /turf)) // how in the FUCK did we manage this
		return  //Yeah just stop.

	if(T.density)
		var/turf/did_it_melt = T.ChangeTurf(T.baseturf)
		if(!did_it_melt.density) //In case some joker finds way to place these on indestructible walls
			reactor.visible_message(SPAN_INFORMATION("[src] melts through [T]!"))
		return

	for(var/obj/structure/holosign/barrier/atmos/fan in reactor.loc.contents)
		reactor.visible_message(SPAN_INFORMATION("[src] violently ruptures through [fan]!"))
		fan.Destroy()
		return

	var/pressure_delta = reactor.air_contents.return_pressure() - environment.return_pressure()
	pressure_delta /= 10

	// based on pressure_pump to equalize pressure
	// already equalized
	if(abs(pressure_delta) < 0.01)
		return FALSE

	if(pressure_delta > 0)
		// transfer from pipe air to environment
		if((reactor.air_contents.total_moles() > 0) && (reactor.air_contents.temperature() > 0))
			var/transfer_moles = pressure_delta * reactor.air_contents.volume / (reactor.air_contents.temperature() * R_IDEAL_GAS_EQUATION)
			transfer_moles = min(transfer_moles, reactor.air_contents.volume)

			var/datum/gas_mixture/removed = reactor.air_contents.remove(transfer_moles)
			environment.merge(removed)
	else
		// transfer from environment to pipe air
		pressure_delta = -pressure_delta
		if((environment.total_moles() > 0) && (environment.temperature() > 0))
			var/transfer_moles = pressure_delta * reactor.air_contents.volume / (environment.temperature() * R_IDEAL_GAS_EQUATION)
			transfer_moles = min(transfer_moles, reactor.air_contents.volume)

			var/datum/gas_mixture/removed = environment.remove(transfer_moles)
			reactor.air_contents.merge(removed)
	return TRUE


/obj/machinery/atmospherics/fission_reactor/process()
	if(stat & BROKEN)
		var/rad_type = pick(GAMMA_RAD, ALPHA_RAD, BETA_RAD)
		radiation_pulse(src, 100, rad_type)
		return

	if(admin_intervention)
		return

	if(!offline && !starting_up)
		var/light_range = clamp((final_power / (50 KW)), 2, 30)
		set_light(light_range, max(reactivity_multiplier, 3), REACTOR_LIGHT_COLOR)
	else
		remove_light()

	if(!control_lockout)
		var/minimum_power = 100 * (1 - (control_rods_remaining / TOTAL_CONTROL_RODS))
		if(operating_power < minimum_power) // oops, control rods stuck
			operating_power++
			update_appearance(UPDATE_OVERLAYS)
		else
			if(desired_power > operating_power)
				operating_power++
				update_appearance(UPDATE_OVERLAYS)
			else if(desired_power < operating_power)
				operating_power--
				update_appearance(UPDATE_OVERLAYS)
	else
		return // stopping here until control lockout is done

	if(operating_power == desired_power && desired_power == 0 && offline != TRUE)
		shut_off()

	if(operating_power > 0 && offline == TRUE)
		boot_up()

	if(operating_power >= 10 && starting_up == TRUE)
		become_operational()

	if(offline || starting_up)
		return

	if(!length(connected_chambers))
		return

	if(safety_override)
		if(operating_power >= 100)
			send_message = FALSE
			countdown()
			return

		// lets fake it a little
		var/heat_capacity = air_contents.heat_capacity()
		var/temp = air_contents.temperature()
		if(heat_capacity && temp < CRITICAL_TEMPERATURE)
			air_contents.set_temperature(temp + rand(20, 200))
		else
			air_contents.set_temperature(CRITICAL_TEMPERATURE)
		if(reactivity_multiplier < 20)
			reactivity_multiplier += (rand(15, 40) / 100)
		else
			reactivity_multiplier = 20

		damage += max(0.5, rand(1, DAMAGE_MAXIMUM * 20) / 20) // this wont actually blow us up early
		return

	final_power = 0 // full resets to be recalculated
	final_heat = 0

	calculate_gas_effects()

	// Calculate the durability loss for all rods in use
	// lower operating power = more durability. Agorithm: 1 / (1 + 2.5^(-0.077 * (x - 65)))
	var/algorithm_decay = 0.077 // higher = steeper decline
	var/durability_loss = 1
	if(operating_power <= 90) // full loss at 90% and above
		durability_loss = round(1 / (1 + 2.5 ** (-algorithm_decay * (operating_power - 65))), 0.01)
	var/operating_rate = operating_percent()

	var/active_chambers
	for(var/obj/machinery/atmospherics/reactor_chamber/chamber in connected_chambers)
		if(chamber.held_rod)
			if(chamber.chamber_state == CHAMBER_DOWN)
				chamber.calculate_stats(operating_rate)
				active_chambers++
				continue
			if(chamber.chamber_state == CHAMBER_UP)
				active_chambers++
				continue

	// gather all our data from the chambers, and enrich if we need to
	for(var/obj/machinery/atmospherics/reactor_chamber/chamber in connected_chambers)
		var/power_total
		var/heat_total
		if(!chamber.held_rod)
			continue
		if(chamber.chamber_state == CHAMBER_OPEN)
			continue
		var/durability_mod = chamber.held_rod.get_durability_mod()
		if(chamber.chamber_state == CHAMBER_DOWN)
			if(chamber.operational) // We generate heat but not power while its down.
				power_total = chamber.power_total * durability_mod // some things have negative power, so we put this before fuel rod checks
			if(istype(chamber.held_rod, /obj/item/nuclear_rod/fuel))
				var/obj/item/nuclear_rod/fuel/fuel_rod = chamber.held_rod
				if(fuel_rod.enrich(chamber.power_mod_total * operating_rate, chamber.power_mod_total * operating_rate))
					if(!chamber.enriching) // so we arnt constantly updating our overlay
						chamber.enriching = TRUE
						chamber.update_icon(UPDATE_OVERLAYS)
				else if(chamber.enriching)
					chamber.enriching = FALSE
					chamber.update_icon(UPDATE_OVERLAYS)

		heat_total = chamber.heat_total * durability_mod
		final_heat += heat_total
		final_power += power_total
		chamber.held_rod.durability -= durability_loss

	if(final_heat)
		average_heatgen = final_heat / active_chambers
	else
		average_heatgen = 0.01

	// Time to decide reactivity coefficient.
	var/temp = air_contents.temperature()
	var/total_mols = air_contents.total_moles()
	if(!temp || !total_mols)
		temp = 0
	if(average_heatgen > AVERAGE_HEAT_THRESHOLD) // the base reactivity from average heat gen
		reactivity_multiplier = 1 + gas_reactivity_bonus + ((average_heatgen - AVERAGE_HEAT_THRESHOLD) / AVERAGE_HEAT_THRESHOLD)
	else
		reactivity_multiplier = 1 + gas_reactivity_bonus
	if(temp > TOTAL_HEAT_THRESHOLD)
		// Math equasion for here: y = a + b * ln(x)
		var/offset = 1 // The offset for the math calc. Gives a flat number boost. (A) component
		var/curve_intensity = 3.5 // Negatively affects the rate of decay. higher = reactivity builds easier. (B) component
		var/heat_component = (temp - TOTAL_HEAT_THRESHOLD) / HEAT_CONVERSION_RATIO // (X) Component
		reactivity_multiplier += (offset + curve_intensity * log(heat_component))

	reactivity_multiplier = clamp(reactivity_multiplier, 1, REACTIVITY_COEFFICIENT_CAP)


	final_heat *= (reactivity_multiplier * 1.5) * HEAT_MODIFIER // proportionally affects heat more
	final_power *= reactivity_multiplier

	final_power = max(final_power, 0) // no negative numbers

	var/rad_type = pick(GAMMA_RAD, ALPHA_RAD, BETA_RAD)

	//Generating  the amount of Plasma created
	var/datum/gas_mixture/temp_gas = new()
	// Math equasion for here: y = a + b * ln(x)
	var/gas_offset = 0.5 // The offset for the math calc. Gives a flat number boost. (A) component
	var/gas_curve_intensity = 1.6 // Affects the rate of decay. higher = reactivity builds easier. (B) component
	var/power_component = max((final_power / 10 MW), 0.01) // (X) Component
	var/h2_amount =  clamp(gas_offset + gas_curve_intensity * log(power_component), 0, 30)
	temp_gas.set_hydrogen(clamp(h2_amount * reactivity_multiplier, 1, 100))
	temp_gas.set_temperature(air_contents.temperature())
	air_contents.merge(temp_gas)

	radiation_pulse(src, 100 * reactivity_multiplier, rad_type)

	// Begin heating the air based off heat produced
	var/heat_capacity = air_contents.heat_capacity()
	if(heat_capacity)
		if(temp < minimum_operating_temp)
			air_contents.set_temperature(max(temp + (final_heat / heat_capacity), temp + 200)) // RAPIDLY reach our minimum temperature or our normal heat gen. Whichever is higher
		else if(temp > HEAT_CAP)
			air_contents.set_temperature(temp + rand(3, 20)) // cap it but slowly gain until we get it down
		else
			air_contents.set_temperature(max(temp + (final_heat / heat_capacity), temp + 2))

	temp = air_contents.temperature()
	if(temp > heat_damage_threshold * 0.9)
		icon_state = "reactor_overheat"
	else if(temp > heat_damage_threshold * 0.6)
		icon_state = "reactor_hot"
	else
		icon_state = "reactor_on"

	// Damage the reactor if conditions are not met, and handle events
	var/new_damage = 0
	if(!total_mols)
		new_damage += DAMAGE_MAXIMUM * MOL_DAMAGE_MULTIPLIER
	else
		if(total_mols <= MOL_MINIMUM)
			new_damage += max(((1 - (total_mols / MOL_MINIMUM)) * DAMAGE_MAXIMUM * MOL_DAMAGE_MULTIPLIER), DAMAGE_MINIMUM)
		if(check_overheating())
			// breaking the equasion up a little for readability. Should look like this: Y = (-AB ^ -X) + A
			var/rate_of_decay = 1.13 // closer to 1 = slower to reach DAMAGE_MAXIMUM. Do not set at or below 1 it will break
			var/damage_increments = -((temp - heat_damage_threshold) / HEAT_DAMAGE_RATE)
			var/damage_calculation = (-DAMAGE_MAXIMUM * (rate_of_decay ** damage_increments)) + DAMAGE_MAXIMUM
			new_damage += max(damage_calculation * HEAT_DAMAGE_MULTIPLIER, DAMAGE_MINIMUM) // god math sucks. This gives decaying increments of damage for heat generation as it gets closer to DAMAGE_MAXIMUM.

			var/pressure = air_contents.return_pressure()
			if(pressure > PRESSURE_MAXIMUM)
				new_damage += PRESSURE_DAMAGE

			new_damage = clamp(new_damage, DAMAGE_MINIMUM, DAMAGE_MAXIMUM)
			var/damage_multiplier = clamp(1 + ((50 - get_integrity()) / 25), 1, 3) // gives a higher event chance below 50% integrity, up to 3x
			damage_multiplier *= EVENT_MODIFIER * gas_event_modifier
			if(final_countdown)
				damage_multiplier = 10
			if(prob(new_damage * damage_multiplier * 0.15)) // rod ejection events. Rarer
				var/list/coolers = list()
				for(var/obj/machinery/atmospherics/reactor_chamber/chamber in connected_chambers)
					if(istype(chamber.held_rod, /obj/item/nuclear_rod/coolant) && chamber.chamber_state == CHAMBER_DOWN)
						coolers += chamber
				if(length(coolers))
					var/obj/machinery/atmospherics/reactor_chamber/failure = coolers[rand(1, length(coolers))]
					if(!failure.welded) // you got lucky punk
						failure.eject_rod()
			if(prob(new_damage * damage_multiplier * 3)) // weld event
				var/list/valid_chambers = list()
				for(var/obj/machinery/atmospherics/reactor_chamber/chamber in connected_chambers)
					if(chamber.chamber_state == CHAMBER_DOWN)
						valid_chambers += chamber
				if(length(valid_chambers))
					while(length(valid_chambers))
						var/obj/machinery/atmospherics/reactor_chamber/failure = valid_chambers[rand(1, length(valid_chambers))]
						if(!failure.welded)
							failure.weld_shut()
							break
						else
							valid_chambers -= failure // just keep cycling through.
			if(prob(new_damage * damage_multiplier * 0.5) && control_rods_remaining > 0) // Control rod failure. more probable
				control_rod_failure()

			if(prob(new_damage * damage_multiplier * 0.05)) // Vent control failure. much rarer
				begin_venting()

	if(damage > WARNING_POINT && (REALTIMEOFDAY - lastwarning) / 10 >= WARNING_DELAY && send_message && !final_countdown)
		try_alarm(new_damage)

	if(new_damage)
		adjust_damage(new_damage)
		send_message = TRUE
		new_damage = 0

	if(damage >= MELTDOWN_POINT)
		send_message = FALSE
		countdown()

/obj/machinery/atmospherics/fission_reactor/proc/try_alarm(new_damage)
	lastwarning = REALTIMEOFDAY
	if(!new_damage)
		radio.autosay("<b>[safe_alert] Integrity: [get_integrity()]%</b>", name, "Engineering")
		send_message = FALSE // only stop sending alerts when no damage has been taken
		return

	switch(get_status())
		if(SUPERMATTER_WARNING)
			radio.autosay("<b>[warning_alert] Integrity: [get_integrity()]%</b>", name, "Engineering")
		if(SUPERMATTER_DANGER)
			radio.autosay("<b>[warning_alert] Integrity: [get_integrity()]%</b>", name, "Engineering")
		if(SUPERMATTER_EMERGENCY)
			radio.autosay(SPAN_BIG("[warning_alert] Integrity: [get_integrity()]%"), name, null)
		if(SUPERMATTER_DELAMINATING)
			radio.autosay(SPAN_BIG("[emergency_alert] Integrity: [get_integrity()]%"), name, null)

/obj/machinery/atmospherics/fission_reactor/proc/get_status()
	var/integrity = get_integrity()
	if(integrity < NGCR_MELTDOWN_PERCENT)
		return SUPERMATTER_DELAMINATING

	if(integrity < NGCR_EMERGENCY_PERCENT)
		return SUPERMATTER_EMERGENCY

	if(integrity < NGCR_DANGER_PERCENT)
		return SUPERMATTER_DANGER

	if((integrity < NGCR_WARNING_PERCENT) || (air_contents.temperature() > CRITICAL_TEMPERATURE))
		return SUPERMATTER_WARNING

	if(air_contents.temperature() > (heat_damage_threshold * 0.8))
		return SUPERMATTER_NOTIFY

	if(offline)
		return SUPERMATTER_INACTIVE

	return SUPERMATTER_NORMAL

/// Turn the reactor off and stop processing.
/obj/machinery/atmospherics/fission_reactor/proc/shut_off()
	starting_up = TRUE
	offline = TRUE
	can_create_power = FALSE
	icon_state = "reactor_off"
	final_heat = 0
	final_power = 0
	reactivity_multiplier = 1
	remove_light()
	playsound(src, 'sound/machines/fission/reactor_shutoff.ogg', 80, 0, 4, ignore_walls = TRUE, channel = CHANNEL_ENGINE)
	soundloop.stop()
	startloop.stop()
	if(send_message)
		radio.autosay("<b>Reactor SCRAM completed successfully. Integrity: [get_integrity()]%</b>", name, "Engineering")
		send_message = FALSE
	if(grill)
		for(var/datum/cooking_surface/surface in grill.surfaces)
			if(surface.on)
				surface.turn_off()
				var/obj/item/reagent_containers/cooking/container = surface.container
				if(istype(container) && container.tracker)
					SEND_SIGNAL(container, COMSIG_COOK_MACHINE_STEP_INTERRUPTED, surface)

/// Begin the startup sequence, but dont turn online yet.
/obj/machinery/atmospherics/fission_reactor/proc/boot_up()
	offline = FALSE
	icon_state = "reactor_starting"
	startloop.start()

/// Make the reactor become fully operational.
/obj/machinery/atmospherics/fission_reactor/proc/become_operational()
	starting_up = FALSE
	offline = FALSE
	can_create_power = TRUE
	playsound(src, 'sound/machines/fission/reactor_startup.ogg', 80, 0, 4, ignore_walls = TRUE)
	startloop.stop()
	soundloop.start()
	if(safety_override)
		icon_state = "reactor_overheat"
	else
		icon_state = "reactor_on"
	set_light(2, 5, REACTOR_LIGHT_COLOR)
	if(grill)
		for(var/datum/cooking_surface/surface in grill.surfaces)
			if(!surface.on)
				surface.turn_on()

/// returns a value from 0 to 1 based off current operating power
/obj/machinery/atmospherics/fission_reactor/proc/operating_percent()
	var/operating_rate = operating_power / 100
	return operating_rate

// Pretty much ripped from the SM
/obj/machinery/atmospherics/fission_reactor/proc/countdown()
	if(final_countdown)
		return
	final_countdown = TRUE
	var/speaking = SPAN_REALLYBIG("[emergency_alert] Reactor structural stability compromised. ")
	for(var/mob/M in GLOB.player_list) // for all players
		var/turf/T = get_turf(M)
		if(istype(T) && atoms_share_level(T, src)) // if the player is on the same zlevel as the SM shared
			SEND_SOUND(M, sound('sound/machines/engine_alert2.ogg')) // then send them the sound file
	radio.autosay(speaking, name, null)
	for(var/i in NGCR_COUNTDOWN_TIME to 0 step -10)
		if(admin_intervention) // Stop exploding if you're frozen by an admin, damn you
			final_countdown = FALSE
			adjust_damage(MELTDOWN_POINT - 1, TRUE) // One point below exploding, so it will re-start the countdown once unfrozen
			return
		if(offline) // Engineers managed to fully turn off the reactor in time
			radio.autosay(SPAN_BIG("[safe_alert]"), name, null)
			final_countdown = FALSE
			remove_filter(list("outline", "icon"))
			return
		else if((i % 50) != 0 && i > 50) // A message once every 5 seconds until the final 5 seconds which count down individualy
			sleep(10)
			continue
		else if(i > 50)
			speaking = "<b>[DisplayTimeText(i, TRUE)] remain before full reactor core meltdown.</b>"
		else
			speaking = SPAN_REALLYBIG("[i * 0.1]...")
		radio.autosay(speaking, name, null)
		sleep(10)

	set_broken()

/// Begins the process of the centcomm doomsday overload
/obj/machinery/atmospherics/fission_reactor/proc/prep_overload()
	desired_power = 0
	INVOKE_ASYNC(src, PROC_REF(scram))
	control_lockout = TRUE
	safety_override = TRUE
	for(var/obj/machinery/atmospherics/reactor_chamber/chamber in connected_chambers)
		chamber.set_idle_overload()

/// Checks all connected chambers for a fuel rod
/obj/machinery/atmospherics/fission_reactor/proc/check_overload_ready()
	if(length(connected_chambers) < MIN_CHAMBERS_TO_OVERLOAD)
		return FALSE
	for(var/obj/machinery/atmospherics/reactor_chamber/chamber in connected_chambers)
		if(chamber.chamber_state == CHAMBER_OVERLOAD_IDLE)
			if(!chamber.held_rod)
				return FALSE
			if(!istype(chamber.held_rod, /obj/item/nuclear_rod/fuel))
				return FALSE
		else
			return FALSE
	return TRUE

/// sets all the chambers to active overload position and unlocks the reactor.
/obj/machinery/atmospherics/fission_reactor/proc/set_overload()
	control_lockout = FALSE
	for(var/obj/machinery/atmospherics/reactor_chamber/chamber in connected_chambers)
		chamber.set_active_overload()

/// The proc for actually blowing up the station. It is too late
/obj/machinery/atmospherics/fission_reactor/proc/finalize_overload()
	icon_state = "meltdown"
	playsound(src, 'sound/machines/alarm.ogg', 100, FALSE, 5)
	if(SSticker && SSticker.mode)
		SSticker.mode.explosion_in_progress = TRUE
		SSticker.record_biohazard_results()
	sleep(100)

	SSblackbox.record_feedback("tally", "fisson_overload", 1, "detonation successful")
	icon_state = "broken"
	GLOB.enter_allowed = 0
	SSticker.station_explosion_cinematic(NUKE_SITE_ON_STATION, null)
	SSticker.mode.station_was_nuked = TRUE
	to_chat(world, "<b>The station was destroyed from a nuclear meltdown!</b>")

	if(!SSticker.mode.check_finished())//If the mode does not deal with the nuke going off so just reboot because everyone is stuck as is
		SSticker.reboot_helper("Station destroyed by nuclear fission meltdown.", "nuke - unhandled ending")
		return

/// Stops the reactor in a somewhat fancy way. Purely for anyone watching the monitor.
/obj/machinery/atmospherics/fission_reactor/proc/scram()
	var/power_fraction = final_power / operating_power
	reactivity_multiplier = 1
	offline = TRUE
	starting_up = TRUE
	final_heat = 0
	var/temp = air_contents.temperature()
	var/temp_fraction

	if(temp && temp > 300)
		temp_fraction = (temp - 300) / operating_power
	while(operating_power > 0)
		operating_power--
		sleep(0.25)
		final_power -= power_fraction
		if(temp)
			temp = air_contents.temperature()
			air_contents.set_temperature(temp - temp_fraction)

	final_power = 0
	icon_state = "reactor_off"

/// Check to see if the reactor is overheating or taking damage from lack of pressure.
/obj/machinery/atmospherics/fission_reactor/proc/check_overheating()
	var/temp = air_contents.temperature()
	var/mols = air_contents.total_moles()
	if(!mols)
		return TRUE
	var/pressure = air_contents.return_pressure()
	if(pressure > PRESSURE_MAXIMUM)
		return TRUE
	if(temp >= heat_damage_threshold)
		return TRUE
	return FALSE

/// Negative Event. Lose a control rod from the reactor.
/obj/machinery/atmospherics/fission_reactor/proc/control_rod_failure()
	if(control_rods_remaining <= 0)
		return
	playsound(src, 'sound/effects/meteorimpact.ogg', 80, FALSE)
	control_rods_remaining--
	radio.autosay("<b>ALERT: Control rod failure! [control_rods_remaining] functional control rods remaining.</b>", name, "Engineering")
	update_icon(UPDATE_OVERLAYS)

/// Negative Event. Ensure the emergency vent opens and gets stuck.
/obj/machinery/atmospherics/fission_reactor/proc/begin_venting()
	if(venting)
		return
	var/datum/effect_system/smoke_spread/bad/smoke = new()
	var/rad_type = pick(ALPHA_RAD, BETA_RAD, GAMMA_RAD)
	for(var/turf/T in view(4, loc))
		T.contaminate_atom(src, 100, rad_type)
	smoke.set_up(3, FALSE, loc)
	smoke.start()
	venting = TRUE
	vent_lockout = TRUE

/// Update the minimum running temperature of the reactor.
/obj/machinery/atmospherics/fission_reactor/proc/update_minimum_temp()
	minimum_operating_temp = 0
	for(var/obj/machinery/atmospherics/reactor_chamber/chamber in connected_chambers)
		if(!chamber.held_rod)
			continue
		if(chamber.chamber_state != CHAMBER_DOWN)
			continue
		if(!chamber.held_rod.minimum_temp_modifier)
			continue
		else if(chamber.held_rod.minimum_temp_modifier > minimum_operating_temp)
			minimum_operating_temp = chamber.held_rod.minimum_temp_modifier

/// Update our new overheat threshold.
/obj/machinery/atmospherics/fission_reactor/proc/update_overheat_threshold(heat_change = 0)
	if(!heat_change)
		return
	heat_damage_threshold += heat_change

/// Adjust how much damage the reactor has, and set broken if we exceed the meltdown point.
/obj/machinery/atmospherics/fission_reactor/proc/adjust_damage(new_damage, set_by_number = FALSE)
	if(set_by_number)
		damage = clamp(new_damage, 0, MELTDOWN_POINT)
	else
		damage += new_damage
		damage = clamp(damage, 0, MELTDOWN_POINT)
	if(damage >= MELTDOWN_POINT && offline)
		set_broken(FALSE)

/// Calculate all of the bonuses and detriments of using specific gasses.
/obj/machinery/atmospherics/fission_reactor/proc/calculate_gas_effects()
	gas_reactivity_bonus = 0
	var/temp_bonus_holder = 0 // heat bounus container
	var/temp_event_holder = 0 // event chance modifier in percentages. 0 to 100
	var/combined_gas = air_contents.total_moles()

	// Math equasion for here: y = a + b * ln(x)
	var/offset = 1 // The offset for the math calc. Gives a flat number boost. (A) component
	var/curve_intensity = 0.7 // Negatively affects the rate of decay. higher = reactivity builds easier. (B) component
	var/gas_component = max((combined_gas - MOLE_BONUS_THRESHOLD) / MOLE_BONUS_COMPONENT, 0.01)
	var/mole_multiplier = max((offset + curve_intensity * log(gas_component)), 0)

	// raw composition of each gas in the chamber, ranges from 0 to 1
	var/n2comp = max(air_contents.nitrogen() / combined_gas, 0)
	var/plasmacomp = max(air_contents.toxins() / combined_gas, 0)
	var/o2comp = max(air_contents.oxygen() / combined_gas, 0)
	var/co2comp = max(air_contents.carbon_dioxide() / combined_gas, 0)
	var/n2ocomp = max(air_contents.sleeping_agent() / combined_gas, 0)

	// dont put a mole multiplier on the event chances o
	if(n2comp)
		temp_bonus_holder += n2comp * N2_OVERHEAT_BONUS * mole_multiplier
		temp_event_holder += n2comp * N2_EVENT_MODIFIER
	if(n2ocomp)
		temp_bonus_holder += n2ocomp * N2O_OVERHEAT_BONUS * mole_multiplier
		temp_event_holder += n2ocomp * N2O_EVENT_MODIFIER
	if(co2comp)
		temp_event_holder += co2comp * CO2_EVENT_MODIFIER * mole_multiplier
	if(o2comp)
		gas_reactivity_bonus += o2comp * O2_REACTIVITY_BONUS * mole_multiplier
		temp_event_holder += o2comp * O2_EVENT_MODIFIER // this one actually should make events more likely
	if(plasmacomp)
		gas_reactivity_bonus += plasmacomp * PLASMA_REACTIVITY_BONUS * mole_multiplier
		temp_bonus_holder += plasmacomp * PLASMA_OVERHEAT_BONUS * mole_multiplier

	temp_event_holder /= 100 // bring between 0 and 1
	gas_event_modifier = 1 - temp_event_holder

	// replace the old bonus witht he new one
	update_overheat_threshold(-gas_overheat_bonus)
	update_overheat_threshold(temp_bonus_holder)
	gas_overheat_bonus = temp_bonus_holder

/// MARK: Rod Chamber

/obj/machinery/atmospherics/reactor_chamber
	name = "rod housing chamber"
	desc = "A chamber used to house nuclear rods of various types to facilitate a fission reaction."
	icon = 'icons/obj/fission/reactor_chamber.dmi'
	icon_state = "chamber_down"
	layer = BELOW_OBJ_LAYER
	resistance_flags = LAVA_PROOF | FIRE_PROOF | ACID_PROOF | FREEZE_PROOF
	max_integrity = 400
	armor = list(melee = 80, bullet = 30, laser = 30, energy = 10, bomb = 40, rad = INFINITY, fire = INFINITY, acid = INFINITY) // fairly robust
	idle_power_consumption = 100
	flags_2 = NO_MALF_EFFECT_2

	/// Each reactor chamber can only be linked to a single reactor, if somehow theres two.
	var/obj/machinery/atmospherics/fission_reactor/linked_reactor
	/// Holds the specific rod inserted into the chamber
	var/obj/item/nuclear_rod/held_rod
	/// Is the chamber up, down, or open
	var/chamber_state = 1
	/// Has the requirements for the rod inside this chamber been met?
	var/requirements_met = FALSE
	/// Is the rod chamber actively running and providing its effects
	var/operational = FALSE
	/// Holds the list of linked neighbors
	var/list/neighbors = list()
	/// skip this chamber when building links
	var/skip_link = FALSE
	/// The total amount of heat produced by this chamber
	var/heat_total
	/// The total amount of power produced by this rod
	var/power_total
	/// Is the chamber currently in an enrichment process
	var/enriching = FALSE
	/// Has the chamber been welded shut. Uh oh!
	var/welded = FALSE
	/// Holds the current accumulated power mod value from its neighbors
	var/power_mod_total = 1
	/// Holds the current accumulated power mod value from its neighbors
	var/heat_mod_total = 1
	/// A simple binary to prevent open/close spam mucking up the anims
	var/lockout = FALSE
	/// holds our durability bar overlay level. Updates overlays if it changes
	var/durability_level = 0
	/// holds our previous overlay.
	var/previous_durability_level

/obj/machinery/atmospherics/reactor_chamber/Initialize(mapload)
	. = ..()
	dupe_check()
	component_parts = list()
	component_parts += new /obj/item/circuitboard/machine/reactor_chamber(null)
	component_parts += new /obj/item/stock_parts/manipulator(src)
	component_parts += new /obj/item/stack/sheet/mineral/plastitanium(src, 2)
	component_parts += new /obj/item/stack/sheet/metal(src, 2)
	component_parts += new /obj/item/stack/cable_coil(src, 5)
	RefreshParts()
	update_icon(UPDATE_OVERLAYS)
	return INITIALIZE_HINT_LATELOAD

/obj/machinery/atmospherics/reactor_chamber/uranium

/obj/machinery/atmospherics/reactor_chamber/uranium/Initialize(mapload)
	. = ..()
	held_rod = new /obj/item/nuclear_rod/fuel/uranium_238(src)

/obj/machinery/atmospherics/reactor_chamber/heavy_water

/obj/machinery/atmospherics/reactor_chamber/heavy_water/Initialize(mapload)
	. = ..()
	held_rod = new /obj/item/nuclear_rod/moderator/heavy_water(src)

// needs to be late so it does not initialize before the reactor or the other neighbors are ready
/obj/machinery/atmospherics/reactor_chamber/LateInitialize()
	. = ..()
	find_link()
	update_icon(UPDATE_OVERLAYS)

/obj/machinery/atmospherics/reactor_chamber/examine(mob/user)
	. = ..()
	. += SPAN_NOTICE("[src] can be sealed/unsealed from its base with a lit welder while in the down position.")
	. += SPAN_NOTICE("<span class='notice'>Alt+click to open and close the shielding while the chamber is raised.")
	. += SPAN_NOTICE("<span class='notice'>Click on the chamber while it is closed to raise and lower it.")
	. += ""

	if(isobserver(user))
		deep_examine(user)

/obj/machinery/atmospherics/reactor_chamber/on_deconstruction()
	if(linked_reactor)
		desync()
	if(held_rod) // we shouldnt be able to decon with this in, but just in case
		if(held_rod.reactor_overheat_modifier)
			linked_reactor.update_overheat_threshold(-held_rod.reactor_overheat_modifier)
		held_rod.forceMove(loc)
		held_rod = null
	return ..()

/obj/machinery/atmospherics/reactor_chamber/Destroy()
	if(held_rod && held_rod.reactor_overheat_modifier)
		linked_reactor.update_overheat_threshold(-held_rod.reactor_overheat_modifier)
	QDEL_NULL(held_rod)
	if(linked_reactor)
		desync()
	return ..()

/obj/machinery/atmospherics/reactor_chamber/update_icon_state()
	return

/obj/machinery/atmospherics/reactor_chamber/update_overlays()
	. = ..()
	overlays.Cut()
	if(welded)
		var/mutable_appearance/weld_overlay = mutable_appearance(layer = BELOW_OBJ_LAYER + 0.03)
		weld_overlay.icon_state = "welded"
		. += weld_overlay
	if(chamber_state == CHAMBER_OPEN)
		var/mutable_appearance/cover_icon = mutable_appearance(layer = ABOVE_ALL_MOB_LAYER + 0.02)
		cover_icon.icon = icon
		cover_icon.icon_state = "door_open"
		. += cover_icon

	if(!held_rod)
		return
	if(chamber_state == CHAMBER_OPEN)
		var/mutable_appearance/rod_overlay = mutable_appearance(layer = ABOVE_ALL_MOB_LAYER + 0.01)
		rod_overlay.icon = icon
		if(istype(held_rod, /obj/item/nuclear_rod/fuel))
			rod_overlay.icon_state = "fuel_overlay"
		if(istype(held_rod, /obj/item/nuclear_rod/coolant))
			rod_overlay.icon_state = "coolant_overlay"
		if(istype(held_rod, /obj/item/nuclear_rod/moderator))
			rod_overlay.icon_state = "moderator_overlay"
		. += rod_overlay

	var/mutable_appearance/state_overlay = mutable_appearance(layer = BELOW_OBJ_LAYER + 0.01)
	state_overlay.icon = icon
	if(chamber_state == CHAMBER_DOWN)
		if(enriching)
			state_overlay.icon_state = "blue"
		else if(requirements_met)
			if(operational)
				state_overlay.icon_state = "green"
			else
				state_overlay.icon_state = "orange"
		else
			if(operational)
				state_overlay.icon_state = "orange"
			else
				state_overlay.icon_state = "red"

		var/mutable_appearance/display_overlay = mutable_appearance(layer = BELOW_OBJ_LAYER + 0.01)
		if(istype(held_rod, /obj/item/nuclear_rod/fuel))
			display_overlay.icon_state = "display_fuel"
		if(istype(held_rod, /obj/item/nuclear_rod/moderator))
			display_overlay.icon_state =  "display_moderator"
		if(istype(held_rod, /obj/item/nuclear_rod/coolant))
			display_overlay.icon_state =  "display_coolant"
		. += display_overlay
	if(chamber_state == CHAMBER_OVERLOAD_IDLE)
		if(held_rod && istype(held_rod, /obj/item/nuclear_rod/fuel))
			state_overlay.icon_state = "overload_idle"
	if(chamber_state == CHAMBER_OVERLOAD_ACTIVE)
		state_overlay.icon_state = "overload_active"
	. += state_overlay

	var/mutable_appearance/durability_overlay = mutable_appearance(icon, layer = BELOW_OBJ_LAYER + 0.01)
	durability_overlay.icon_state = "dur_[previous_durability_level]"
	. += durability_overlay

// check for multiple on a tile and nuke it
/obj/machinery/atmospherics/reactor_chamber/proc/dupe_check()
	var/chambers_found = 0
	for(var/obj/machinery/atmospherics/reactor_chamber/chamber in range(0, src))
		chambers_found++
		if(chambers_found > 1)
			visible_message(SPAN_WARNING("[src] has no room to deploy and breaks apart!"))
			chamber.deconstruct()

/obj/machinery/atmospherics/reactor_chamber/attack_hand(mob/user)
	if(!user)
		return
	if(linked_reactor && linked_reactor.admin_intervention)
		to_chat(user, SPAN_WARNING("An unusual force prevents you from moving the chamber!"))
		return
	if(stat & NOPOWER)
		to_chat(user, SPAN_WARNING("The chamber's locks wont disengage without power!"))
		return
	if(user.loc == loc)
		to_chat(user, SPAN_WARNING("You can't raise the rod chamber while standing on it!"))
		return

	if(!is_mecha_occupant(user))
		add_fingerprint(user)

	switch(chamber_state)
		if(CHAMBER_DOWN, CHAMBER_OVERLOAD_IDLE)
			if(!Adjacent(user))
				return
			if(welded)
				to_chat(user, SPAN_WARNING("[src] is welded shut. It wont budge!"))
				return
			var/delay = 1 SECONDS
			if(linked_reactor && !linked_reactor.offline)
				delay = 8 SECONDS
				if(!is_mecha_occupant(user)) // mech users are unaffected
					burn_handler(user)
			if(do_after_once(user, delay, target = src, allow_moving = FALSE))
				if(!Adjacent(user)) // for mecha users
					return
				raise()
				return

		if(CHAMBER_UP)
			if(do_after_once(user, 2 SECONDS, target = src, allow_moving = FALSE))
				if(chamber_state != CHAMBER_UP) // so that we cant lower while in the open state
					return
				lower()
				return

		if(CHAMBER_OPEN)
			if(issilicon(user)) // handled seperately. Dont pull out this way
				return
			if(!held_rod)
				to_chat(user, SPAN_WARNING("There is no rod inside of the chamber to remove!"))
				return
			else
				if(user.put_in_hands(held_rod))
					held_rod.add_fingerprint(user)
					held_rod = null
					playsound(loc, 'sound/machines/podopen.ogg', 50, 1)
					update_icon(UPDATE_OVERLAYS)
				else
					to_chat(user, SPAN_WARNING("Your hands are currently full!"))
					return
		if(CHAMBER_OVERLOAD_ACTIVE)
			to_chat(user, SPAN_ALERT("The chamber lockdowns have been engaged, preventing it from being raised!"))
			return
	update_icon(UPDATE_OVERLAYS)

/obj/machinery/atmospherics/reactor_chamber/AltClick(mob/user, modifiers)
	if(!Adjacent(user))
		return
	if(lockout)
		return
	if(linked_reactor && linked_reactor.admin_intervention)
		to_chat(user, SPAN_WARNING("An unusual force prevents you from manipulating the chamber!"))
		return
	if(chamber_state == CHAMBER_UP)
		if(!lockout)
			open()
		return
	if(chamber_state == CHAMBER_OPEN)
		if(panel_open == TRUE)
			to_chat(user, SPAN_WARNING("You must close the maintenance panel before the chamber can be sealed!"))
			return
		if(!lockout)
			close()
		return

/obj/machinery/atmospherics/reactor_chamber/item_interaction(mob/living/user, obj/item/used, list/modifiers)
	if(issilicon(user) && get_dist(src, user) > 1)
		attack_hand(user)
		return ITEM_INTERACT_COMPLETE

	if(istype(used, /obj/item/nuclear_rod))
		if(chamber_state == CHAMBER_OPEN)
			if(!held_rod)
				if(panel_open)
					to_chat(user, SPAN_WARNING("The open maintenance panel prevents the rod from slotting inside!"))
				if(user.transfer_item_to(used, src, force = TRUE))
					held_rod = used
					playsound(loc, 'sound/machines/podclose.ogg', 50, 1)
					update_icon(UPDATE_OVERLAYS)
					return ITEM_INTERACT_COMPLETE

/obj/machinery/atmospherics/reactor_chamber/screwdriver_act(mob/living/user, obj/item/I)
	if(!I.use_tool(src, user, 0, volume = 0))
		return
	. = TRUE
	if(chamber_state != CHAMBER_OPEN)
		to_chat(user, SPAN_ALERT("[src] must be raised and opened first!"))
		return
	if(linked_reactor && !linked_reactor.offline)
		to_chat(user, SPAN_ALERT("The safety locks prevent maintenance while the reactor is on!"))
		return
	if(held_rod)
		to_chat(user, SPAN_ALERT("You cannot reach the maintenance panel if a rod inside."))
		return
	default_deconstruction_screwdriver(user, icon_state, icon_state, I)

/obj/machinery/atmospherics/reactor_chamber/crowbar_act(mob/living/user, obj/item/I)
	. = TRUE
	default_deconstruction_crowbar(user, I)

/obj/machinery/atmospherics/reactor_chamber/welder_act(mob/living/user, obj/item/I)
	if(user.a_intent == INTENT_HARM)
		if(chamber_state != CHAMBER_DOWN)
			return ITEM_INTERACT_COMPLETE
		to_chat(user, SPAN_WARNING("You begin [welded ? "welding" : "unwelding"] [src]"))
		if(!I.use_tool(src, user, (6 SECONDS) * I.toolspeed, volume = I.tool_volume))
			return ITEM_INTERACT_COMPLETE
		if(welded)
			unweld()
		else
			weld_shut()
		update_icon(UPDATE_OVERLAYS)
		return ITEM_INTERACT_COMPLETE
	else
		if(obj_integrity < max_integrity)
			to_chat(user, SPAN_WARNING("You begin repairing the [src]"))
			if(!I.use_tool(src, user, (3 SECONDS) * I.toolspeed, volume = I.tool_volume))
				return ITEM_INTERACT_COMPLETE
			obj_integrity = max_integrity // lets make sure we can keep these healthy if need be
		else
			to_chat(user, SPAN_WARNING("the [src] is not in need of repair"))
		return ITEM_INTERACT_COMPLETE


/obj/machinery/atmospherics/reactor_chamber/multitool_act(mob/living/user, obj/item/I)
	. = TRUE
	deep_examine(user)

/obj/machinery/atmospherics/reactor_chamber/proc/deep_examine(mob/user)
	if(chamber_state != CHAMBER_DOWN)
		return
	if(!held_rod)
		to_chat(user, SPAN_WARNING("There is no nuclear rod inside this housing chamber."))
		return ITEM_INTERACT_COMPLETE
	if(!linked_reactor)
		to_chat(user, SPAN_WARNING("This chamber is not connected to a reactor."))
		return ITEM_INTERACT_COMPLETE
	var/operating_rate = linked_reactor.operating_percent()
	var/durability_mod = held_rod.get_durability_mod()
	var/list/message = list()
	message += SPAN_NOTICE("[held_rod] is currently contained within this chamber.")

	message += ""

	if(held_rod.durability == 0)
		message += SPAN_NOTICE("The rod has been fully depleted and rendered inert.")
		to_chat(user, message)
		return ITEM_INTERACT_COMPLETE
	else
		message += SPAN_NOTICE("Rod integrity is at [(held_rod.durability / held_rod.max_durability) * 100]%.")

	message += ""

	if(power_total && operational)
		message += SPAN_NOTICE("The chamber is currently producing [(power_total * operating_rate * durability_mod) / 1000] KiloWatts of energy.")
		message += SPAN_NOTICE("The chamber has a power modifier of [power_mod_total].")
	else
		message += SPAN_NOTICE("The chamber is producing no power.")
	if(istype(held_rod, /obj/item/nuclear_rod/fuel))
		var/obj/item/nuclear_rod/fuel/rod = held_rod
		if(rod.power_enrich_progress >= rod.enrichment_cycles && rod.power_enrich_result)
			message += SPAN_NOTICE("[held_rod] has been power enriched")
		else
			message += SPAN_NOTICE("[held_rod] has not yet finished a power enrichment process.")

	message += ""

	if(heat_total)
		message += SPAN_NOTICE("The chamber is currently producing [heat_total * HEAT_MODIFIER * operating_rate * durability_mod] joules of heat.")
		message += SPAN_NOTICE("The chamber has a heat modifier of [heat_mod_total].")
	else
		message += SPAN_NOTICE("The chamber is producing no heat.")
	if(istype(held_rod, /obj/item/nuclear_rod/fuel))
		var/obj/item/nuclear_rod/fuel/rod = held_rod
		if(rod.heat_enrich_progress >= rod.enrichment_cycles && rod.heat_enrich_result)
			message += SPAN_NOTICE("[held_rod] has been heat enriched")
		else
			message += SPAN_NOTICE("[held_rod] has not yet finished a heat enrichment process.")

	to_chat(user, chat_box_examine(message.Join("<br>")))
	return ITEM_INTERACT_COMPLETE

/obj/machinery/atmospherics/reactor_chamber/proc/raise(playsound = TRUE)
	chamber_state = CHAMBER_UP
	icon_state = "chamber_up_anim"
	lockout = TRUE
	addtimer(CALLBACK(src, PROC_REF(finish_raise_anim)), 0.7 SECONDS)
	density = TRUE
	operational = FALSE
	enriching = FALSE
	requirements_met = FALSE
	layer = ABOVE_MOB_LAYER
	power_total = 0
	check_minimum_modifier()
	if(held_rod && held_rod.reactor_overheat_modifier)
		linked_reactor.update_overheat_threshold(-held_rod.reactor_overheat_modifier)
	if(playsound)
		playsound(loc, 'sound/items/deconstruct.ogg', 50, 1)
	if(istype(held_rod, /obj/item/nuclear_rod/fuel))
		if(linked_reactor.offline)
			held_rod.start_rads()
		else
			held_rod.start_rads(linked_reactor.reactivity_multiplier)

	update_icon()
	for(var/obj/machinery/atmospherics/reactor_chamber/chamber in neighbors)
		if(!chamber.held_rod)
			return
		if(chamber.check_status())
			chamber.requirements_met = TRUE
		else
			chamber.requirements_met = FALSE

/obj/machinery/atmospherics/reactor_chamber/proc/finish_raise_anim()
	lockout = FALSE
	icon_state = "chamber_up"

/obj/machinery/atmospherics/reactor_chamber/proc/lower(playsound = TRUE)
	density = FALSE
	layer = BELOW_OBJ_LAYER
	if(playsound)
		playsound(loc, 'sound/items/deconstruct.ogg', 50, 1)
	if(linked_reactor && linked_reactor.safety_override)
		chamber_state = CHAMBER_OVERLOAD_IDLE
		icon_state = "chamber_overload"
		if(linked_reactor.check_overload_ready())
			linked_reactor.set_overload()
	else
		chamber_state = CHAMBER_DOWN
		icon_state = "chamber_down_anim"
		addtimer(CALLBACK(src, PROC_REF(finish_down_anim)), 1.3 SECONDS)
		if(!held_rod)
			update_icon()
			return
		else
			held_rod.stop_rads()
			if(held_rod.reactor_overheat_modifier)
				linked_reactor.update_overheat_threshold(held_rod.reactor_overheat_modifier)
			previous_durability_level = clamp(ROUND_UP((held_rod.durability / held_rod.max_durability) - 20), 0, 6)
		if(check_status())
			requirements_met = TRUE
		else
			requirements_met = FALSE
		check_minimum_modifier()
	update_icon()

/obj/machinery/atmospherics/reactor_chamber/proc/finish_down_anim()
	icon_state = "chamber_down"

/obj/machinery/atmospherics/reactor_chamber/proc/close(playsound = TRUE)
	chamber_state = CHAMBER_UP
	new /obj/effect/temp_visual/chamber_closing(loc)
	addtimer(CALLBACK(src, PROC_REF(finish_closing)), 0.5 SECONDS)
	lockout = TRUE
	if(playsound)
		playsound(loc, 'sound/machines/switch.ogg', 50, 1)

/obj/machinery/atmospherics/reactor_chamber/proc/finish_closing()
	lockout = FALSE
	icon_state = "chamber_up"
	update_icon(UPDATE_OVERLAYS)

/obj/machinery/atmospherics/reactor_chamber/proc/open(playsound = TRUE)
	chamber_state = CHAMBER_OPEN
	icon_state = "chamber_open"
	var/cover_icon = mutable_appearance(icon, icon_state = "doors_opening", layer = ABOVE_ALL_MOB_LAYER + 0.02)
	add_overlay(cover_icon)
	lockout = TRUE
	addtimer(CALLBACK(src, PROC_REF(finish_opening)), 0.5 SECONDS)
	if(playsound)
		playsound(loc, 'sound/machines/switch.ogg', 50, 1)
	update_icon(UPDATE_OVERLAYS)

/obj/machinery/atmospherics/reactor_chamber/proc/finish_opening()

	lockout = FALSE

/obj/machinery/atmospherics/reactor_chamber/proc/set_idle_overload()
	if(chamber_state == CHAMBER_DOWN)
		chamber_state = CHAMBER_OVERLOAD_IDLE
		icon_state = "chamber_overload"
	operational = FALSE
	enriching = FALSE
	requirements_met = FALSE
	update_icon(UPDATE_OVERLAYS)

/obj/machinery/atmospherics/reactor_chamber/proc/set_active_overload()
	chamber_state = CHAMBER_OVERLOAD_ACTIVE
	icon_state = "chamber_down"
	update_icon(UPDATE_OVERLAYS)

/// Gets the neighbors of the current chamber, and adds itself to its neighbors. can prompt a cascade of linking
/obj/machinery/atmospherics/reactor_chamber/proc/get_neighbors()
	var/turf/nearby_turf
	for(var/direction in GLOB.cardinal)
		nearby_turf = get_step(src, direction)
		for(var/obj/machinery/atmospherics/reactor_chamber/chamber in nearby_turf)
			if(chamber.linked_reactor && chamber.linked_reactor != linked_reactor) // if for some god forsaken reason we have two
				continue
			if((chamber in neighbors) || (src in chamber.neighbors))
				continue
			neighbors += chamber
			chamber.neighbors += src
			if(!chamber.linked_reactor)
				chamber.linked_reactor = linked_reactor
				linked_reactor.connected_chambers += chamber
				chamber.get_neighbors()

///  Removes the chamber from neighbor from its neighbors, and forces them to run status checks
/obj/machinery/atmospherics/reactor_chamber/proc/desync()
	if(length(neighbors)) // for when we need to rerun this
		for(var/obj/machinery/atmospherics/reactor_chamber/chamber in neighbors)
			chamber.neighbors -= src
		neighbors.Cut()
	if(linked_reactor)
		linked_reactor.connected_chambers -= src
		linked_reactor.clear_reactor_network(restart = TRUE)


/// Forms the two-way link between the reactor and the chamber, then searches for valid neighbors.
/obj/machinery/atmospherics/reactor_chamber/proc/form_link(obj/machinery/atmospherics/fission_reactor/reactor)
	if(linked_reactor || skip_link) // prevent duplicate linking or unwanted chambers
		return
	linked_reactor = reactor
	if(!(src in linked_reactor.connected_chambers))
		linked_reactor.connected_chambers += src
	get_neighbors()

/// Searches for a valid reactor or linked chamber nearby
/obj/machinery/atmospherics/reactor_chamber/proc/find_link()
	if(linked_reactor) // we already have a linked reactor
		return
	var/turf/nearby_turf
	for(var/direction in GLOB.cardinal)
		nearby_turf = get_step(src, direction)
		for(var/obj/machinery/atmospherics/fission_reactor/reactor in nearby_turf.contents)
			form_link(reactor)
			return TRUE
		for(var/obj/structure/filler/filler in nearby_turf.contents)
			if(filler.parent && istype(filler.parent, /obj/machinery/atmospherics/fission_reactor))
				form_link(filler.parent)
				return TRUE
		for(var/obj/machinery/atmospherics/reactor_chamber/chamber in nearby_turf.contents)
			if(chamber.linked_reactor)
				form_link(chamber.linked_reactor)
				return TRUE
	return FALSE

/// validates that all rod requirements are being met
/obj/machinery/atmospherics/reactor_chamber/proc/check_status()
	if(!held_rod)
		return FALSE

	var/list/temp_requirements = list()
	temp_requirements += held_rod.adjacent_requirements // a temporary modable holder
	if(!temp_requirements)
		return TRUE

	for(var/obj/machinery/atmospherics/reactor_chamber/chamber in neighbors)
		if(!chamber.operational)
			continue
		if(chamber.held_rod.type in temp_requirements)
			temp_requirements -= chamber.held_rod.type
		for(var/requirement in temp_requirements)
			if(chamber.held_rod.type in typesof(requirement))
				temp_requirements -= requirement
				break

	if(!length(temp_requirements))
		return TRUE

	return FALSE

/obj/machinery/atmospherics/reactor_chamber/process()
	if(!linked_reactor)
		if(find_link())
			get_neighbors()
			return
		else
			return
	if(linked_reactor.admin_intervention)
		return
	if(!held_rod)
		return
	if(chamber_state != CHAMBER_DOWN) /// we should only process reactor info when down
		return
	durability_level = clamp(ROUND_UP(((held_rod.durability / held_rod.max_durability) * 5) - 0.8), 0, 5)
	if(durability_level != previous_durability_level)
		previous_durability_level = durability_level
		update_icon(UPDATE_OVERLAYS)
	if(!linked_reactor.offline)
		held_rod.calc_stat_decrease() // only need to re-calc durability loss when the chamber is down and reactor is online
	if(linked_reactor && linked_reactor.safety_override && !linked_reactor.control_lockout) // we only remove control lockout when the others are ready
		if(chamber_state == CHAMBER_OVERLOAD_IDLE && istype(held_rod, /obj/item/nuclear_rod/fuel))
			set_active_overload() // for latejoiners
	if(!requirements_met && !operational)
		if(check_status())
			requirements_met = TRUE
			update_icon(UPDATE_OVERLAYS)
			return
	if(requirements_met && !operational)
		if(prob(20))
			operational = TRUE
			update_icon(UPDATE_OVERLAYS)
			return
	if(!requirements_met && operational) /// if it loses requirements, it wont immediately turn off
		if(istype(held_rod.type, /obj/item/nuclear_rod/coolant))
			if(prob(10)) // higher rates of coolant rod failures once they're already on. Good luck.
				operational = FALSE
				update_icon(UPDATE_OVERLAYS)
		else if(prob(1))
			enriching = FALSE
			operational = FALSE
			update_icon(UPDATE_OVERLAYS)
		return

/obj/machinery/atmospherics/reactor_chamber/process_atmos()
	if(!held_rod) // no rod no heat
		return
	if(!linked_reactor)
		return
	if(linked_reactor.offline)
		return
	if(chamber_state != CHAMBER_OPEN && chamber_state != CHAMBER_UP)
		return
	if(linked_reactor.admin_intervention)
		return

	var/datum/milla_safe/chamber_process/milla = new()
	milla.invoke_async(src)

/datum/milla_safe/chamber_process

/datum/milla_safe/chamber_process/on_run(obj/machinery/atmospherics/reactor_chamber/chamber)
	var/turf/T = get_turf(chamber)
	var/datum/gas_mixture/environment = get_turf_air(T)

	if(isnull(T)) // We have a null turf...something is wrong, stop processing this entity.
		return PROCESS_KILL

	if(!istype(chamber.loc, /turf)) // how in the FUCK did we manage this
		return  //Yeah just stop.

	if(T.density)
		var/turf/did_it_melt = T.ChangeTurf(T.baseturf)
		if(!did_it_melt.density) //In case some joker finds way to place these on indestructible walls
			chamber.visible_message(SPAN_WARNING("[src] melts through [T]!"))
		return

	var/heat_capacity = environment.heat_capacity()
	var/heat_change = max(chamber.heat_total / heat_capacity) * HEAT_MODIFIER // the hotter the rod, the hotter the air
	var/temp = environment.temperature()
	if(chamber.chamber_state == CHAMBER_UP) // its not fully exposed yet, and heating the reactor
		heat_change *= 0.25
	heat_change = max(heat_change, 1) //always heat up at least a little
	environment.set_temperature(temp + heat_change)

/// Calculate how much heat and energy we should be making
/obj/machinery/atmospherics/reactor_chamber/proc/calculate_stats(operating_rate = 0)
	power_total = (held_rod.power_amount * operating_rate)
	heat_total = (held_rod.heat_amount * operating_rate)

	power_mod_total = 1
	heat_mod_total = 1
	for(var/obj/machinery/atmospherics/reactor_chamber/chamber in neighbors)
		if(!chamber.held_rod || chamber.chamber_state == CHAMBER_OPEN)
			continue
		if(held_rod.heat_amount > 0) // no negatives amplified here.
			heat_mod_total *= chamber.held_rod.current_heat_mod // we generate heat even when its not operational
		if(operational && chamber.chamber_state == CHAMBER_DOWN)
			if(held_rod.power_amount > 0) // no negatives amplified here.
				power_mod_total *= chamber.held_rod.current_power_mod

	power_total *= power_mod_total
	heat_total *= heat_mod_total

/obj/machinery/atmospherics/reactor_chamber/proc/eject_rod()
	raise(FALSE)
	open(FALSE)
	var/datum/effect_system/smoke_spread/bad/smoke = new()
	smoke.set_up(5, FALSE, loc)
	smoke.start()
	var/rad_type = pick(ALPHA_RAD, BETA_RAD, GAMMA_RAD)
	for(var/turf/T in view(2, loc))
		T.contaminate_atom(src, 300, rad_type)
	var/distance_traveled = rand(6, 20)
	var/angle = rand(0, 360)
	var/turf/end = get_turf_in_angle(angle, loc, distance_traveled)
	var/obj/effect/immovablerod/nuclear_rod/nuclear_rod = new(loc, end)
	var/matrix/M = new
	M.Turn(angle)
	nuclear_rod.transform = M
	nuclear_rod.icon = held_rod.icon
	nuclear_rod.icon_state = held_rod.icon_state
	nuclear_rod.held_rod = held_rod
	held_rod.forceMove(src)
	held_rod = null
	update_icon(UPDATE_OVERLAYS)
	playsound(src, 'sound/effects/bang.ogg', 70, TRUE)
	audible_message("POW!")

/obj/machinery/atmospherics/reactor_chamber/proc/weld_shut()
	welded = TRUE
	playsound(loc, 'sound/items/welder2.ogg', 60, 1)
	update_icon(UPDATE_OVERLAYS)

/obj/machinery/atmospherics/reactor_chamber/proc/unweld()
	welded = FALSE
	playsound(loc, 'sound/items/welder2.ogg', 60, 1)
	update_icon(UPDATE_OVERLAYS)

/obj/machinery/atmospherics/reactor_chamber/proc/burn_handler(mob/user)
	var/burn_damage = CHAMBER_HEAT_DAMAGE
	if(linked_reactor.check_overheating()) // ouch, even hotter!
		burn_damage *= 2
	if(istype(user, /mob/living/carbon/human))
		var/mob/living/carbon/human/H = user
		if(H.gloves)
			var/obj/item/clothing/gloves/G = H.gloves
			if(G.max_heat_protection_temperature)
				burn_damage *= 0.5
			else if(HAS_TRAIT(H, TRAIT_RESISTHEAT) || HAS_TRAIT(H, TRAIT_RESISTHEATHANDS))
				burn_damage *= 0.5
		var/obj/item/organ/external/affecting = H.get_organ("[user.hand ? "l" : "r" ]_hand")
		if(affecting.receive_damage(0, burn_damage)) // burn damage to them fingers
			H.UpdateDamageIcon()
			H.updatehealth()
	else if(isliving(user))
		var/mob/living/L = user
		if(issilicon(L)) // more resistant by default
			burn_damage *= 0.5
		L.adjustFireLoss(burn_damage)

/obj/machinery/atmospherics/reactor_chamber/proc/check_minimum_modifier()
	if(!linked_reactor)
		return
	if(!held_rod)
		return
	if(!held_rod.minimum_temp_modifier)
		return
	if(held_rod.minimum_temp_modifier >= linked_reactor.minimum_operating_temp)
		linked_reactor.update_minimum_temp()

/obj/effect/immovablerod/nuclear_rod
	name = "\improper Nuclear Coolant Rod"
	desc = "Oh fuck this shouldnt be happening."
	notify = FALSE
	var/obj/held_rod

/// lets not break the reactor with this.
/obj/effect/immovablerod/nuclear_rod/clong_thing(atom/victim)
	if(istype(victim, /obj/machinery/atmospherics/fission_reactor))
		return
	if(istype(victim, /obj/structure/filler))
		var/obj/structure/filler/filler = victim
		if(filler.parent && istype(filler.parent, /obj/machinery/atmospherics/fission_reactor))
			return
	if(istype(victim, /obj/machinery/atmospherics/reactor_chamber))
		return

	if(isobj(victim) && victim.density)
		victim.ex_act(EXPLODE_HEAVY)
	else if(ismob(victim))
		if(ishuman(victim))
			var/mob/living/carbon/human/H = victim
			H.visible_message(SPAN_DANGER("[H.name] is penetrated by an ejected coolant rod!"),
				SPAN_USERDANGER("The rod penetrates you!"),
				SPAN_DANGER("You hear a CLANG!"))
			H.adjustBruteLoss(100) // not as strong as a normal rod
		if(victim.density || prob(20)) // we want to hit more things than a normal rod though
			victim.ex_act(EXPLODE_HEAVY)

/obj/effect/immovablerod/nuclear_rod/Move()
	. = ..()
	if(loc == end)
		qdel(src)

/obj/effect/immovablerod/nuclear_rod/Destroy()
	held_rod.forceMove(end)
	return ..()

/// MARK: Gas Node

/obj/machinery/atmospherics/unary/reactor_gas_node
	name = "reactor gas intake"
	desc = "A sturdy-looking gas inlet that injects gas into the reactor"
	icon = 'icons/obj/fission/reactor_parts.dmi'
	icon_state = "gas_node"
	layer = GAS_PIPE_VISIBLE_LAYER
	max_integrity = 2000
	target_pressure = 100000 // maximum pressure in KPA
	flags_2 = NO_MALF_EFFECT_2

	/// Hold which reactor the intake is connected to.
	var/obj/machinery/atmospherics/fission_reactor/linked_reactor
	/// Is this vent taking air in or out. TRUE by default.
	var/intake_vent = TRUE

/obj/machinery/atmospherics/unary/reactor_gas_node/output
	name = "Reactor Gas Extractor"
	intake_vent = FALSE

/obj/machinery/atmospherics/unary/reactor_gas_node/Initialize(mapload)
	. = ..()
	component_parts = list()
	component_parts += new /obj/item/circuitboard/machine/reactor_gas_node(null)
	component_parts += new /obj/item/stack/sheet/metal(src, 2)
	component_parts += new /obj/item/stack/cable_coil(src, 2)
	initialize_directions = dir
	RefreshParts()
	update_icon()
	return INITIALIZE_HINT_LATELOAD

// needs to be late so it does not initialize before the reactor
/obj/machinery/atmospherics/unary/reactor_gas_node/LateInitialize()
	. = ..()
	form_link()

/obj/machinery/atmospherics/unary/reactor_gas_node/examine(mob/user)
	. = ..()
	. += SPAN_NOTICE("A wrench can be used to alter the direction of the node.")
	. += SPAN_NOTICE("Gas nodes will only link with reactors when facing a reactor from the side opposite of the inlet pipe.")

/obj/machinery/atmospherics/unary/reactor_gas_node/process_atmos()
	if(stat & (NOPOWER|BROKEN))
		return FALSE
	if(!linked_reactor)
		return FALSE
	if(linked_reactor.admin_intervention)
		return FALSE
	if(linked_reactor.safety_override) // we dont want to cool down an intentional runaway reactor
		return FALSE
	var/datum/gas_mixture/network1
	var/datum/gas_mixture/network2

	if(intake_vent)
		network1 = linked_reactor.air_contents
		network2 = air_contents
	if(!intake_vent)
		network1 = air_contents
		network2 = linked_reactor.air_contents

	if(!network1 || !network2)
		return FALSE

	// this is basically passive gate code
	var/output_starting_pressure = network1.return_pressure()
	var/input_starting_pressure = network2.return_pressure()

	//Calculate necessary moles to transfer using PV = nRT
	if((network2.total_moles() > 0) && (network2.temperature() > 0))
		var/pressure_delta = min(target_pressure - output_starting_pressure, (input_starting_pressure - output_starting_pressure) / 2)
		if(intake_vent)
			pressure_delta = max(pressure_delta, 3) // always work at least a little bit when inputting gas
		var/transfer_moles = pressure_delta * network1.volume / (network2.temperature() * R_IDEAL_GAS_EQUATION)

		//Actually transfer the gas
		var/datum/gas_mixture/removed = network2.remove(transfer_moles)
		network1.merge(removed)

		parent.update = 1

	return 1

/obj/machinery/atmospherics/unary/reactor_gas_node/screwdriver_act(mob/living/user, obj/item/I)
	default_deconstruction_screwdriver(user, icon_state, icon_state, I)

/obj/machinery/atmospherics/unary/reactor_gas_node/crowbar_act(mob/living/user, obj/item/I)
	to_chat(user, SPAN_INFORMATION("You begin to pry out the internal piping..."))
	if(I.use_tool(src, user, 3 SECONDS, volume = I.tool_volume))
		default_deconstruction_crowbar(user, I)

/obj/machinery/atmospherics/unary/reactor_gas_node/wrench_act(mob/user, obj/item/I)
	var/list/choices = list("West" = WEST, "East" = EAST, "South" = SOUTH, "North" = NORTH)
	var/selected = tgui_input_list(user, "Select a direction for the connector.", "Connector Direction", choices)
	if(!selected)
		return ITEM_INTERACT_COMPLETE
	if(!Adjacent(user))
		to_chat(user, SPAN_WARNING("You moved away before construction was finished"))
	if(!I.use_tool(src, user, 3 SECONDS, volume = I.tool_volume))
		return ITEM_INTERACT_COMPLETE
	if(!Adjacent(user))
		to_chat(user, SPAN_WARNING("You moved away before construction was finished"))
		return ITEM_INTERACT_COMPLETE
	dir = choices[selected]
	initialize_directions = dir
	for(var/obj/machinery/atmospherics/target in get_step(src, dir))
		if(target.initialize_directions & get_dir(target,src))
			node = target
			break
	form_link()
	initialize_atmos_network()
	update_icon()
	return ITEM_INTERACT_COMPLETE

/obj/machinery/atmospherics/unary/reactor_gas_node/proc/form_link()
	linked_reactor = null
	var/turf/T = get_step(src, REVERSE_DIR(dir))
	for(var/obj/machinery/atmospherics/fission_reactor/reactor in T)
		linked_reactor = reactor
	for(var/obj/structure/filler/filler in T)
		if(istype(filler.parent, /obj/machinery/atmospherics/fission_reactor))
			linked_reactor = filler.parent

/obj/machinery/atmospherics/unary/reactor_gas_node/multitool_act(mob/living/user, obj/item/I)
	to_chat(user, SPAN_INFORMATION("You begin to reverse the gas flow direction..."))
	if(do_after_once(user, 1 SECONDS, TRUE, src, allow_moving = FALSE))
		intake_vent = !intake_vent
		if(intake_vent)
			name = "Reactor Gas Intake"
		else
			name = "Reactor Gas Extractor"
	return ..()

/obj/item/circuitboard/machine/reactor_gas_node
	board_name = "Reactor Gas Node"
	icon_state = "engineering"
	build_path = /obj/machinery/atmospherics/unary/reactor_gas_node
	origin_tech = "engineering=2"
	req_components = list(
		/obj/item/stack/cable_coil = 2,
		/obj/item/stack/sheet/metal = 2,
	)

#undef REACTOR_NEEDS_DIGGING
#undef REACTOR_NEEDS_CROWBAR
#undef REACTOR_NEEDS_PLASTITANIUM
#undef REACTOR_NEEDS_SCREWDRIVER
#undef REACTOR_NEEDS_WELDING
#undef REACTOR_NEEDS_PLASTEEL
#undef REACTOR_NEEDS_WRENCH

#undef REACTOR_LIGHT_COLOR

#undef TOTAL_CONTROL_RODS

#undef MIN_CHAMBERS_TO_OVERLOAD

#undef EVENT_MODIFIER

#undef HEAT_MODIFIER
#undef HEAT_CAP
#undef AVERAGE_HEAT_THRESHOLD
#undef TOTAL_HEAT_THRESHOLD
#undef HEAT_CONVERSION_RATIO
#undef REACTIVITY_COEFFICIENT_CAP

#undef NGCR_MELTDOWN_PERCENT
#undef NGCR_EMERGENCY_PERCENT
#undef NGCR_DANGER_PERCENT
#undef NGCR_WARNING_PERCENT
#undef CRITICAL_TEMPERATURE
#undef WARNING_POINT
#undef EMERGENCY_POINT
#undef MELTDOWN_POINT

#undef NGCR_COUNTDOWN_TIME
#undef WARNING_DELAY

#undef HEAT_DAMAGE_RATE
#undef MOL_MINIMUM
#undef PRESSURE_MAXIMUM
#undef PRESSURE_DAMAGE
#undef DAMAGE_MINIMUM
#undef DAMAGE_MAXIMUM
#undef MOL_DAMAGE_MULTIPLIER
#undef HEAT_DAMAGE_MULTIPLIER
#undef EXPLOSION_MODIFIER

#undef CHAMBER_HEAT_DAMAGE

#undef MOLE_BONUS_THRESHOLD
#undef MOLE_BONUS_COMPONENT
#undef N2_OVERHEAT_BONUS
#undef N2_EVENT_MODIFIER
#undef N2O_OVERHEAT_BONUS
#undef N2O_EVENT_MODIFIER
#undef CO2_EVENT_MODIFIER
#undef O2_EVENT_MODIFIER
#undef O2_REACTIVITY_BONUS
#undef PLASMA_REACTIVITY_BONUS
#undef PLASMA_OVERHEAT_BONUS
